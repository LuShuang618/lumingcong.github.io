一、re.compile(pattern,flags=0)

      pattern: 编译时用的表达式字符串。

      flags 编译标志位，用于修改正则表达式的匹配方式
举例：
          import re
          #r'\w*of\w*'是所要提取的表达式结构
          pattern = re.compile(r'\w*of\w*',re.S)
          #text输入要被提取的文本
          text = "The Recommand of Regular Expression "
          #print（正则结构.findall（被提取的文本））     findall进行遍历
          print(pattern.findall(text))   
          执行结果：['of']
          ********************************************************************************************************************
二、  re.findall(pattern, string, flags=0)
        re.findall遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表。
例如：
        p = re.compile(r'\d+')
        print(p.findall('o1n2m3k4'))
        执行结果如下：
        ['1', '2', '3', '4']
        ****************************************************************************************************************************
三、re.match(pattern, string, flags=0)

       决定RE是否在字符串刚开始的位置匹配。//注：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符'$'
       
       pattern :编译时用的表达式字符串。
       
       string :被提取的文档，字符串
       
       flags 编译标志位，用于修改正则表达式的匹配方式
举例：
        print(re.match('com','comwww.runcomoob').group())
        print(re.match('com','Comwww.runcomoob',re.I).group())
        执行结果如下：
        com
        com
        *********************************************************************************************************************************
四、re.search(pattern, string, flags=0)

        re.search函数会在字符串内查找模式匹配,只要找到第一个匹配然后返回，如果字符串没有匹配，则返回None。   
例如：        
        import re
          a = "123abc456"
           print(re.search("([0-9]*)([a-z]*)([0-9]*)",a).group(0))   #123abc456,返回整体
           print(re.search("([0-9]*)([a-z]*)([0-9]*)",a).group(1))   #123
           print(re.search("([0-9]*)([a-z]*)([0-9]*)",a).group(2))   #abc
           print(re.search("([0-9]*)([a-z]*)([0-9]*)",a).group(3))   #456
          ###group(1) 列出第一个括号匹配部分，group(2) 列出第二个括号匹配部分，group(3) 列出第三个括号匹配部分。###
          *********************************************************************************************************************************************
五、re.split(pattern, string[, maxsplit])
          按照能够匹配的子串将string分割后返回列表。

          可以使用re.split来分割字符串，如：re.split(r'\s+', text)；将字符串按空格分割成一个单词列表。
           maxsplit用于指定最大分割次数，不指定将全部分割。
格式：

            print(re.split('\d+','one1two2three3four4five5'))
            执行结果如下：
            ['one', 'two', 'three', 'four', 'five', '']

*******************************************************************************************************************************************
六、re.sub(pattern, repl, string, count)
            使用re替换string中每一个匹配的子串后返回替换后的字符串。

格式：
            import re
            text = "JGood is a handsome boy, he is cool, clever, and so on..."
            print(re.sub(r'\s+', '-', text))
            执行结果如下：
            JGood-is-a-handsome-boy,-he-is-cool,-clever,-and-so-on...
            
            ps:如：re.sub(r'\s', lambda m: '[' + m.group(0) + ']', text, 0)；将字符串中的空格' '替换为'[ ]'。
            
 *******************************************************************************************************************************         
            
 七、易错点区分           
 1、re.match与re.search与re.findall的区别：

    re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。
2、贪婪匹配与非贪婪匹配

    *?,+?,??,{m,n}?    前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配（非贪婪匹配）
 *****************************************************************************************************************************************   
八、正则的小实践
1、匹配电话号码

      p = re.compile(r'\d{3}-\d{6}')
      print(p.findall('010-628888'))
2、匹配IP

      re.search(r"(([01]?\d?\d|2[0-4]\d|25[0-5])\.){3}([01]?\d?\d|2[0-4]\d|25[0-5]\.)","192.168.1.1")
